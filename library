# буду записывать интересные решения и код сюда

 # заполнение столбца индексацией по условию: 
 df.loc[(df['column'] == X, 'column2') = Y]
 _________________________________________________________
 # функция по сравнению значений в двух массивах:
 
 def error_count(array1, array2):
    count = 0
    for i in range(len(array1)):
        if array1[i] != array2[i]:
            count += 1
    return count

print("Ошибок:", error_count(test_target, test_predictions))
_________________________________________________________

# цикл для проверки максимальной глубины исследования в модели: 

for i in range(1,6):
    model = DecisionTreeClassifier(max_depth=i, random_state = 12345)
    model.fit(features_train, target_train)
    predictions_valid = model.predict(features_valid)
    accuracy = accuracy_score(target_valid, predictions_valid)
    print('max_depth =', i, ':', accuracy)
_________________________________________________________

# цикл в функции для перемножения чисел внутри себя: 

def mse(answers, predictions):
    total = 0
    for i in range(len(answers)):
        total += (answers[i] - predictions[i])**2 # < прибавьте квадрат ошибки >
    result = total/len(answers) # < поделите сумму на количество объектов >
    return result
    
answers = [623, 253, 150, 237]
predictions = [649, 253, 370, 148]

print(mse(answers, predictions))
_________________________________________________________
# функция для обращения к чему-то по индексу: 

def revenue(target, probabilities, count):
    probs_sorted = probabilities.sort_values(ascending=False)
    selected = target[probs_sorted.index][:count]
    return sum(1000*selected)

target = pd.Series([1,   1,   0,   0,  1,    0])
probab = pd.Series([0.2, 0.9, 0.8, 0.3, 0.5, 0.1])

res = revenue(target, probab, 3)

print(res)
_________________________________________________________

# сравнение двух списков:

result=list(set(Ans) & set(Word))
сюда же - разность
_________________________________________________________
# цикл чтобы убрать все цифры в строке:

for j in range(1,28):
    data_pivot['unnamed'][j]= "".join(c for c in str(data_pivot['unnamed'][j]) if c.isalpha())
_________________________________________________________
# нахождение минимального расстояния до точки: 

avenues_df = pd.DataFrame([0, 153, 307, 524], index=['Park', 'Lexington', '3rd', '2nd'])
streets_df = pd.DataFrame([0, 81, 159, 240, 324], index=['76', '75', '74', '73', '72'])

address = ['Lexington', '74']
taxies = [
    ['Park', '72'],
    ['2nd', '75'],
    ['3rd', '76'],
]
address_vector = np.array([avenues_df.loc[address[0]], streets_df.loc[address[1]]])
taxi_distances = []
for i in taxies:
    dist = distance.cityblock(address_vector, np.array([avenues_df.loc[i[0]], streets_df.loc[i[1]]]))
    taxi_distances.append(dist)
index=np.array(taxi_distances)
print(taxies[np.array(taxi_distances).argmin()])
_________________________________________________________
# поиск минимального элемента по индексу
preference_index = 12
preference_vector = df_realty.loc[preference_index].values

distances = []

for i in range(df_realty['комнаты'].count()):
    x = df_realty.loc[12].values
    distances.append(distance.euclidean(x, df_realty.loc[i].values))
#val, idx = min((val, idx) for (idx, val) in enumerate(distances))
#best_index = idx
best_index = np.array(distances).argsort()[1] 
#print(best_index)
